### 설명

**입력에 사용**   
`System.in.read`를 통해 문자열 파싱없이 바이트 단위로 아스키 코드를 통해 정수처리 하는 코드

### 사용 경우
- 입력이 연속된 정수로 이루어져 있을 때.
- 입력받는 정수의 값이 클 때.

위 경우가 바이트 단위로 입력받아 빠른 계산을 할 수 있다.

만약 연속된 정수로 이루어져 있지 않고 숫자 사이에 공백이나 구분자가 있다면, `BufferedReader`와`StringTokenizer`를 이용하는 편이 좋다.


### 코드 설명
```java
    static int read() throws IOException {
        int c, n = System.in.read() & 15;
        while ((c = System.in.read()) > 47 && c < 58) n = (n << 3) + (n << 1) + (c & 15);
        return n;
    }
```
&nbsp;
&nbsp;
&nbsp;

###  `System.in.read() & 15`
1. `System.in.read()`로 바이트 단위로 아스키 코드로 읽어온다.

2. 아스키코드로 숫자 0은 48로 이진법으로 0011 0000에 해당한다.

3. 비트연산자 &는 각 비트를 비교해서 둘 다 1일 경우에만 1을 반환하고 그 외에는 0을 반환하는 **AND**연산을 한다.

4. 15를 이진법으로 하면 1111이다. 이 둘을 & 연산을 하면 아스키 코드로 어떤 수가 입력되어도 연산할 수 있는 비트는 4자리이기에 뒷 4자리를 제외하고는 전부 0이 되어 값에 영향을 미치지 못하세 된다.

5. 15는 1111이고 아스키코드로 0을 뜻하는 48의 비트 4자리는 0000으로 시작하기에 둘이 비교해서 둘 다 1일 경우에만 1을 반환하면 입력한 정수와 같은 값을 얻을 수 있다.
### `while ((c = System.in.read()) > 47 && c < 58) n = (n << 3) + (n << 1) + (c & 15);`
1. `c = System.in.read()`로 읽어온 아스키 코드가 0~9에 해당하는 정수일 경우에만 반복문을 반복한다.

2. `<<`연산은 만약 0011 이라는 비트가 있을 때 이동을 뜻하는 연산자다. `3 << 1`일 경우 왼쪽으로 한칸 이동한다. 0011에서 0110이 된다.

3. `<<`의 오른쪽에 이동할 칸 수를 정해주는데 연산 결과는 왼쪽 수 * 2의 오른쪽 수 제곱이다.

4. 위는 즉 n * 2<sup>3</sup> + n * 2<sup>1</sup>이 되므로 n * 10과 같은 값이 나온다.
5. 입력한 순서대로 10배를 해줘 자릿수를 옮기며 입력한 정수를 얻는다.
